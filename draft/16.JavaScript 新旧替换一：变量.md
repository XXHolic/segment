# JavaScript 新旧替换一：变量声明
## <a name="index"></a> 目录
- [场景](#situation)
- [ES5 方式](#style)
- [ES2015+ 方式](#style)
  - [变量类型](#link)
  - [变量声明](#link)
- [参考资料](#reference)



## <a name="situation"></a> 场景
在工作中，最初接触 ES5 的语法比较多，后来渐渐的接触了新的语法。由于历史原因，需要在不同的项目使用不同的语法。时间长了，发现在写代码的时候，偏向用更加熟悉的旧语法，但感觉这么下去不太妙。于是，就想着针对工作中常用的语法，用新的进行对比替换，然后记录总结一下，有意识的更新相关知识点。以下参考版本：ECMA-262, 9th edition, June 2018。

## ES5 方式
在 ECMAScript 中，变量可以用来保存任何类型的数据。每个变量只是一个用于保存值的占位符而已。在 ES5 中，使用 var 声明变量，这种声明方式的特点有：
1. 声明的变量不赋值，会初始化默认值为 `undefined`。
```javascript
var testVariable;
console.info('testVariable=',testVariable); // undefined
```
2. 可以一条语句定义多个变量，变量之间用董浩分开即可。
```javascript
var name = 'Tom',
    age = 15;
```
3. 如果省略 `var` 声明，则会创建一个全局变量，这样会污染全局变量，这种方式不推荐。
4. 用 `var` 声明的变量会自动添加到最近的环境中，当查找变量的时候，搜索过程是从作用域链的前端开始，向上逐级查询。如果在局部环境中找到了变量，则停止搜索，使用找到的变量。5. 用 `var` 声明的变量会自动添加到最近的环境中，当查找变量的时候，搜索过程是从作用域链的前端开始，向上逐级查询。如果在局部环境中找到了变量，则停止搜索，使用找到的变量。
5. 同一作用域内重复声明同一变量时，后声明会覆盖前声明。
```javascript
var testVariable = '123';
var testVariable = '12';
console.info('testVariable=',testVariable); //12
```
6. 声明的变量会发生“变量提升”，也就是说可以声明先使用，这种方式不推荐。
```javascript
console.info('testVariable=',testVariable); // undefined
var testVariable = 1;
```

使用 `var` 声明比较经典的现象是在 `for` 循环语句中。
```javascript
function printNum() {
  var numArray = [];
  for(var i=0;i<5;i++) {
    numArray.push(function (){
      console.info(i);
    })
  }
  numArray[0]();
}
printNum(); // 5
```
for 循环中用 var 声明的变量 i 在函数 printNum 作用域中都有效，每次循环执行语句 `console.info(i)` 中的 i 和 for 循环中声明的 i，指向的是同一个 i，执行完最后一次循环，i 的值就是 5。

## ES2015+ 方式
新增的声明变量方式有：let const。
### let 声明
用法跟 var 类似，这种方式不同的地方有：
1. 声明的变量，在 let 所在的代码块内有效。
```javascript
{
  let testLet = 1;
  var testVar = 2;
}
console.info('testVar=',testVar); // 2
console.info('testLet=',testLet); // Uncaught ReferenceError: testLet is not defined
```
2. 不会“变量提升”，要先声明后使用，否则会报错。
```javascript
console.info('testLet=',testLet); // Uncaught ReferenceError: testLet is not defined
let testLet = 1;
```
这种过早访问 let 声明的引用导致的 ReferenceError 严格说叫做“暂时死亡区”（Temporal Dead Zone，TDZ）错误。这种情况下，使用 `typeof` 就会有问题。
```javascript
console.info(typeof testVar);
console.info(typeof testLet);
var testVar = '123';
var testLet = 123; // Uncaught ReferenceError: testLet is not defined
```
3. 同一作用域内，不允许重复声明同一个变量。
```javascript
let testLet = 1;
let testLet = '123'; // Uncaught SyntaxError: Identifier 'testLet' has already been declared
```
同样在 `for` 循环中使用时：
```javascript
function printNum() {
  var numArray = [];
  for(let i=0;i<5;i++) {
    numArray.push(function (){
      console.info(i);
    })
  }
  numArray[0]();
}
printNum(); // 0
```
`for` 循环头部的 let i 为每次循环都重新声明了一个 i。头部的声明是一个作用域，循环体内是另外一个单独的作用域。
```javascript
for(let i=0;i<2;i++) {
  let i = '123';
  console.info(i);
}
// 123
// 123
```

### const 声明
这种形式的声明，是用于创建常量。常量不是对这个值本身的限制，而是对赋值的那个变量的限制。变量实际是指向一个内存地址，const 就对这个内存地址所保存的数据进行了限制。对于简单的数据（例如数值、字符串、布尔值），值就保存在那个内存地址中，就等同于常量。如果符合类型的数据（例如数组和对象），内存地址中保存的就是一个指向实际数据的指针，const 保证的是这个指针固定，这个指针实际指向的内容就不能控制了。
```javascript
const testConst = [1,2];
testConst.push(3);
console.info(testConst); // [1,2,3]
```
这种方式的特点有：
1. 同 let 一样，所在的代码块内有效。
```javascript
{
  const TEST = "0.618";
}
console.info(TEST); // Uncaught ReferenceError: TEST is not defined
```
2. 不会“变量提升”，要先声明且初始化后才能使用，否则会报错。同样存在“暂时死亡区”。
```javascript
const K = 1.13198824;
console.info(K);
const TEST;
console.info(TEST);
// SyntaxError: Missing initializer in const declaration
```
3. 同 let 一样，同一作用域内，不允许重复声明同一个变量。

## <a name="reference"></a> 参考资料
[ECMAScript Standard][url-ecma-standard]
[JavaScript高级程序设计（第3版） ][url-javascript-design]
[你不知道的JavaScript（上卷） ][url-unknow-javascript-1]
[你不知道的JavaScript（下卷） ][url-unknow-javascript-3]
[ECMAScript 6 入门][url-es6-ruanyifeng]


[url-ecma-standard]:http://www.ecma-international.org/publications/standards/Ecma-262.htm
[url-javascript-design]:http://www.ituring.com.cn/book/946
[url-unknow-javascript-1]:http://www.ituring.com.cn/book/1488
[url-unknow-javascript-3]:http://www.ituring.com.cn/book/1666
[url-es6-ruanyifeng]:http://es6.ruanyifeng.com/




[url-ecma-9th]:http://www.ecma-international.org/ecma-262/9.0/index.html#sec-intro
[url-mdn-immediately-function]:https://developer.mozilla.org/en-US/docs/Glossary/IIFE
[url-wiki-immediately-function]:https://en.wikipedia.org/wiki/Immediately_invoked_function_expression
[url-blog-immediately-function]:http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife